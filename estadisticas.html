<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Estad√≠sticas - South Traders</title>

  <!-- Material Design Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      background: #1a1a1a;
      min-height: 100vh;
      padding: 20px;
    }

    .header {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid #4CAF50;
    }

    .header h1 {
      color: #4CAF50;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .back-btn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      transition: background 0.3s;
    }

    .back-btn:hover {
      background: #45a049;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      border: 1px solid #333;
      transition: border-color 0.3s;
    }

    .stat-card:hover {
      border-color: #4CAF50;
    }

    .stat-card h3 {
      color: #999;
      font-size: 14px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .stat-card .value {
      font-size: 32px;
      font-weight: bold;
      color: white;
    }

    .stat-card .subtitle {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }

    .charts-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .chart-card {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      border: 1px solid #333;
    }

    .chart-card h2 {
      color: #4CAF50;
      margin-bottom: 20px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .chart-card canvas {
      max-height: 300px;
    }

    .ranking-card {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      margin-bottom: 20px;
      border: 1px solid #333;
    }

    .ranking-card h2 {
      color: #4CAF50;
      margin-bottom: 20px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ranking-list {
      list-style: none;
    }

    .ranking-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      border-bottom: 1px solid #333;
      transition: background 0.2s;
    }

    .ranking-item:hover {
      background: #333;
    }

    .ranking-item:last-child {
      border-bottom: none;
    }

    .ranking-position {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
      min-width: 40px;
    }

    .ranking-position.first { color: #FFD700; }
    .ranking-position.second { color: #C0C0C0; }
    .ranking-position.third { color: #CD7F32; }

    .ranking-info {
      flex: 1;
      margin: 0 20px;
    }

    .ranking-name {
      font-weight: bold;
      color: white;
      margin-bottom: 3px;
    }

    .ranking-detail {
      font-size: 12px;
      color: #888;
    }

    .ranking-value {
      font-size: 18px;
      font-weight: bold;
      color: white;
      text-align: right;
    }

    .ranking-value .unit {
      font-size: 12px;
      color: #888;
      font-weight: normal;
    }

    .top-rankings-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin-bottom: 20px;
    }

    .top-rankings-grid .ranking-card {
      margin-bottom: 0;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: white;
      font-size: 18px;
    }

    .no-data {
      text-align: center;
      padding: 20px;
      color: #666;
      font-style: italic;
    }

    @media (max-width: 768px) {
      .charts-container {
        grid-template-columns: 1fr;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }

      .top-rankings-grid {
        grid-template-columns: 1fr;
      }

      .header {
        flex-direction: column;
        gap: 15px;
        text-align: center;
      }

      .header h1 {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>
      <span class="material-icons">bar_chart</span>
      Estad√≠sticas del Sistema
    </h1>
    <button class="back-btn" onclick="window.location.href='marketplace.html'">
      <span class="material-icons">arrow_back</span>
      Volver
    </button>
  </div>

  <div id="loadingIndicator" class="loading">
    <span class="material-icons" style="font-size: 48px; animation: spin 2s linear infinite;">hourglass_empty</span>
    <p>Cargando estad√≠sticas...</p>
  </div>

  <div id="statsContent" style="display: none;">
    <!-- KPIs principales -->
    <div class="stats-grid">
      <div class="stat-card">
        <h3><span class="material-icons">shopping_cart</span> Total √ìrdenes</h3>
        <div class="value" id="totalOrders">0</div>
        <div class="subtitle">Todas las √≥rdenes del sistema</div>
      </div>
      <div class="stat-card">
        <h3><span class="material-icons">attach_money</span> Venta Total</h3>
        <div class="value" id="totalRevenue">$0</div>
        <div class="subtitle">Suma de todas las √≥rdenes</div>
      </div>
      <div class="stat-card">
        <h3><span class="material-icons">paid</span> Costo de Venta</h3>
        <div class="value" id="totalCost">$0</div>
        <div class="subtitle">Monto total al costo</div>
      </div>
      <div class="stat-card">
        <h3><span class="material-icons">trending_up</span> Ganancia Total</h3>
        <div class="value" id="totalProfit">$0</div>
        <div class="subtitle">Venta - Costo</div>
      </div>
      <div class="stat-card">
        <h3><span class="material-icons">people</span> Clientes Totales</h3>
        <div class="value" id="totalClients">0</div>
        <div class="subtitle">Clientes en el sistema</div>
      </div>
      <div class="stat-card">
        <h3><span class="material-icons">inventory</span> Productos Vendidos</h3>
        <div class="value" id="totalProducts">0</div>
        <div class="subtitle">Unidades totales vendidas</div>
      </div>
    </div>

    <!-- Gr√°ficos -->
    <div class="charts-container">
      <div class="chart-card">
        <h2><span class="material-icons">bar_chart</span> √ìrdenes por Estado</h2>
        <canvas id="statusChart"></canvas>
      </div>
      <div class="chart-card">
        <h2><span class="material-icons">show_chart</span> Ventas por D√≠a (√∫ltimos 30 d√≠as)</h2>
        <canvas id="salesChart"></canvas>
      </div>
      <div class="chart-card">
        <h2><span class="material-icons">calendar_today</span> Ventas por Mes (√∫ltimos 12 meses)</h2>
        <canvas id="salesByMonthChart"></canvas>
      </div>
      <div class="chart-card">
        <h2><span class="material-icons">date_range</span> Ventas por A√±o</h2>
        <canvas id="salesByYearChart"></canvas>
      </div>
    </div>

    <!-- Gr√°ficos de Dispositivos y Browsers -->
    <div class="charts-container">
      <div class="chart-card">
        <h2><span class="material-icons">devices</span> Total de Conexiones por Dispositivo</h2>
        <canvas id="devicesChart"></canvas>
        <div style="color: #888; font-size: 12px; margin-top: 10px; text-align: center;">
          Acumulado desde octubre 2025
        </div>
      </div>
      <div class="chart-card">
        <h2><span class="material-icons">web</span> Total de Conexiones por Navegador</h2>
        <canvas id="browsersChart"></canvas>
        <div style="color: #888; font-size: 12px; margin-top: 10px; text-align: center;">
          Acumulado desde octubre 2025
        </div>
      </div>
    </div>

    <!-- Rankings -->
    <!-- Contenedor para Top 10 Vendedores y Usuarios lado a lado -->
    <div class="top-rankings-grid">
      <div class="ranking-card">
        <h2><span class="material-icons">emoji_events</span> Top 10 Vendedores (por √≥rdenes creadas)</h2>
        <ul class="ranking-list" id="vendedoresRanking">
          <li class="no-data">Cargando...</li>
        </ul>
      </div>

      <div class="ranking-card">
        <h2><span class="material-icons">login</span> Top 10 Usuarios M√°s Conectados</h2>
        <ul class="ranking-list" id="usuariosRanking">
          <li class="no-data">Cargando...</li>
        </ul>
      </div>
    </div>

    <!-- Top 10 Productos separado -->
    <div class="ranking-card">
      <h2><span class="material-icons">trending_up</span> Top 10 Productos M√°s Vendidos</h2>
      <ul class="ranking-list" id="productosRanking">
        <li class="no-data">Cargando...</li>
      </ul>
    </div>

    <!-- Gr√°fico de P√°ginas M√°s Visitadas -->
    <div class="chart-card" style="margin-top: 20px;">
      <h2><span class="material-icons">analytics</span> P√°ginas M√°s Visitadas</h2>
      <canvas id="pagesChart"></canvas>
      <div id="pagesChartSubtitle" style="color: #888; font-size: 12px; margin-top: 10px; text-align: center;">
        Acumulado desde octubre 2025
      </div>
    </div>
  </div>

  <style>
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>

  <script type="module">
    // Firebase configuration
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getFirestore, collection, getDocs, query, where, orderBy, limit, doc, getDoc, addDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyCXjSGtVGfQas_cEyjmI0RTaeEl94jdp6g",
      authDomain: "carrito-138c3.firebaseapp.com",
      projectId: "carrito-138c3",
      storageBucket: "carrito-138c3.firebasestorage.app",
      messagingSenderId: "1002158386608",
      appId: "1:1002158386608:web:5f4f9a3e876a0f44dfe7a4"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // API Configuration
    const API_BASE = '/api';
    const AUTH_URL = `${API_BASE}/authenticate`;
    const STOCK_URL = `${API_BASE}/stock`;

    const CREDENTIALS = {
      username: 'Api',
      md5password: 'e10adc3949ba59abbe56e057f20f883e'
    };

    let authToken = null;
    let tokenExpiresAt = 0;

    // Helper functions
    function normalizeKey(key) {
      return String(key)
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]/g, '');
    }

    function getFirstExisting(row, candidateKeys) {
      const normalizedMap = new Map();
      for (const k of Object.keys(row || {})) {
        normalizedMap.set(normalizeKey(k), k);
      }
      for (const c of candidateKeys) {
        const nk = normalizeKey(c);
        if (normalizedMap.has(nk)) {
          const originalKey = normalizedMap.get(nk);
          return row[originalKey];
        }
      }
      return undefined;
    }

    function parseLocaleNumber(str) {
      if (typeof str !== 'string') return NaN;
      const cleaned = str.replace(/\./g, '').replace(',', '.');
      return parseFloat(cleaned);
    }

    // API Authentication
    async function authenticate() {
      if (authToken && Date.now() < tokenExpiresAt) {
        return authToken;
      }

      try {
        const response = await fetch(AUTH_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(CREDENTIALS)
        });

        if (!response.ok) {
          throw new Error(`Authentication failed: ${response.statusText}`);
        }

        const data = await response.json();
        authToken = data.token;
        tokenExpiresAt = Date.now() + (data.expires ? data.expires * 1000 : 55 * 60 * 1000);
        console.log('‚úÖ Authenticated with API');
        return authToken;
      } catch (error) {
        console.error('‚ùå Authentication error:', error);
        throw error;
      }
    }

    // Fetch products from API
    async function fetchProductsFromAPI() {
      try {
        const token = await authenticate();
        const url = `${STOCK_URL}?format=JSON&ViewOption=0`;

        const response = await fetch(url, {
          headers: { Authorization: `Bearer ${token}` }
        });

        if (!response.ok) {
          throw new Error(`API request failed: ${response.statusText}`);
        }

        const data = await response.json();
        console.log(`‚úÖ Loaded ${data.length} products from API`);
        return data;
      } catch (error) {
        console.error('‚ùå Error fetching products:', error);
        throw error;
      }
    }

    // Extract cost from product data
    function extractCostFromProduct(raw) {
      let costoContable = getFirstExisting(raw, ['Costo Contable', 'CostoContable']);
      costoContable = Number.isFinite(Number(costoContable)) ? Number(costoContable) : parseLocaleNumber(String(costoContable ?? ''));
      if (!Number.isFinite(costoContable)) costoContable = 0;
      return costoContable;
    }

    // Check if user is authenticated and is admin
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = 'login.html';
        return;
      }

      // Track page visit
      try {
        await addDoc(collection(db, 'page_visits'), {
          page: 'estadisticas',
          pageName: 'Estad√≠sticas',
          userId: user.uid,
          userEmail: user.email,
          timestamp: serverTimestamp()
        });
        console.log('üìä Page visit tracked: estadisticas');
      } catch (error) {
        console.error('Error tracking page visit:', error);
      }

      // Check if user is admin
      const userDoc = await getDocs(query(collection(db, 'usuarios'), where('email', '==', user.email)));
      if (userDoc.empty || !userDoc.docs[0].data().admin) {
        alert('‚ö†Ô∏è No tienes permisos para acceder a esta p√°gina');
        window.location.href = 'marketplace.html';
        return;
      }

      // Load statistics
      await loadStatistics();
    });

    async function loadStatistics() {
      try {
        console.log('üìä Cargando estad√≠sticas...');

        // Load products from API to get costs
        console.log('üì¶ Cargando productos desde la API...');
        const productsData = await fetchProductsFromAPI();

        // Create map of articulo -> cost
        const costMap = new Map();
        productsData.forEach(product => {
          const articulo = getFirstExisting(product, ['Art√≠culo', 'Articulo', 'item', 'Item', 'Codigo', 'C√≥digo']);
          if (articulo) {
            const cost = extractCostFromProduct(product);
            costMap.set(String(articulo).trim(), cost);
          }
        });
        console.log(`‚úÖ Mapa de costos creado con ${costMap.size} productos`);

        // Get all orders
        const ordersSnapshot = await getDocs(collection(db, 'pedidos'));
        const orders = [];
        ordersSnapshot.forEach(doc => {
          orders.push({ id: doc.id, ...doc.data() });
        });

        console.log(`‚úÖ √ìrdenes cargadas: ${orders.length}`);

        // Get all clients for email-to-client mapping
        const clientsSnapshot = await getDocs(collection(db, 'clientes'));
        const allClients = [];
        clientsSnapshot.forEach(doc => {
          allClients.push({ id: doc.id, ...doc.data() });
        });
        console.log(`‚úÖ Clientes cargados: ${allClients.length}`);

        // Helper function to map email to client name
        const getClientDisplayName = (email, clientCode = '', clientName = '') => {
          // SPECIAL CASE: cortizjctech -> Trading Next USA Black
          if (email && email.toLowerCase() === 'cortizjctech@gmail.com') {
            console.log('üîß [STATS] Detectado cortizjctech, retornando Trading Next USA Black');
            return 'TRADING NEXT USA BLACK (407)';
          }

          // If clientName is already provided, use it
          if (clientName && clientName !== 'Cliente sin nombre') {
            return clientCode ? `${clientName} (${clientCode})` : clientName;
          }

          // Try to find client by email
          if (email && allClients.length > 0) {
            const clientByEmail = allClients.find(c => c.email && c.email.toLowerCase() === email.toLowerCase());
            if (clientByEmail) {
              const nombre = clientByEmail.nombre || clientByEmail.codigo || 'Sin nombre';
              const codigo = clientByEmail.codigo || '';
              console.log(`‚úÖ [STATS] Email ${email} mapeado a cliente ${nombre} (${codigo})`);
              return codigo ? `${nombre} (${codigo})` : nombre;
            }
          }

          // Try to find client by code
          if (clientCode && allClients.length > 0) {
            // Handle codes with underscore like "407_rmpNpzeT"
            const baseCode = clientCode.includes('_') ? clientCode.split('_')[0] : clientCode;
            const clientByCode = allClients.find(c => c.codigo === baseCode);
            if (clientByCode) {
              const nombre = clientByCode.nombre || baseCode;
              console.log(`‚úÖ [STATS] C√≥digo ${clientCode} mapeado a cliente ${nombre} (${baseCode})`);
              return `${nombre} (${baseCode})`;
            }
          }

          // Fallback: return email or 'Sin cliente'
          return email || 'Sin cliente';
        };

        // Filter out test/development users
        const testUsers = [
          'cristiansan@gmail.com',
          'santifn.axp@gmail.com',
          'matensegiles@gmail.com',
          'matense.giles@gmail.com',
          'test@test.com.ar',
          'test@test.com',
          'prueba@prueba.com',
          'cuenta@demo.com.ar'
        ];

        const filteredOrders = orders.filter(order => {
          const userEmail = order.usuarioEmail || order.clienteEmail || '';
          return !testUsers.includes(userEmail.toLowerCase());
        });

        console.log(`üìä √ìrdenes despu√©s de filtrar usuarios de prueba: ${filteredOrders.length} (excluidas: ${orders.length - filteredOrders.length})`);

        // Replace orders array with filtered orders
        orders.length = 0;
        orders.push(...filteredOrders);

        // Get total clients count (already loaded above)
        const clients = allClients.length;

        // Calculate KPIs
        const totalOrders = orders.length;
        const totalRevenue = orders.reduce((sum, order) => sum + (order.total || 0), 0);
        const totalCost = orders.reduce((sum, order) => {
          if (order.items && Array.isArray(order.items)) {
            return sum + order.items.reduce((itemSum, item) => {
              const quantity = item.quantity || 0;
              const articulo = String(item.articulo || '').trim();

              // Get cost from map, fallback to item's costoContable if available
              let costPrice = costMap.get(articulo);
              if (costPrice === undefined || costPrice === 0) {
                costPrice = item.costoContable || 0;
              }

              return itemSum + (quantity * costPrice);
            }, 0);
          }
          return sum;
        }, 0);
        const totalProducts = orders.reduce((sum, order) => {
          if (order.items && Array.isArray(order.items)) {
            return sum + order.items.reduce((itemSum, item) => itemSum + (item.quantity || 0), 0);
          }
          return sum;
        }, 0);

        // Calculate profit
        const totalProfit = totalRevenue - totalCost;

        // Update KPIs
        document.getElementById('totalOrders').textContent = totalOrders;
        document.getElementById('totalRevenue').textContent = '$' + totalRevenue.toFixed(2);
        document.getElementById('totalCost').textContent = '$' + totalCost.toFixed(2);
        document.getElementById('totalProfit').textContent = '$' + totalProfit.toFixed(2);
        document.getElementById('totalClients').textContent = clients;
        document.getElementById('totalProducts').textContent = totalProducts;

        // Color the profit value based on positive/negative
        const profitElement = document.getElementById('totalProfit');
        if (totalProfit >= 0) {
          profitElement.style.color = '#4CAF50'; // Green for profit
        } else {
          profitElement.style.color = '#f44336'; // Red for loss
        }

        // Log cost calculation details
        console.log(`üí∞ C√°lculo de costos:`);
        let itemsWithCost = 0;
        let itemsWithoutCost = 0;
        orders.forEach(order => {
          if (order.items && Array.isArray(order.items)) {
            order.items.forEach(item => {
              const articulo = String(item.articulo || '').trim();
              const cost = costMap.get(articulo);
              if (cost && cost > 0) {
                itemsWithCost++;
              } else {
                itemsWithoutCost++;
                if (itemsWithoutCost <= 5) { // Log first 5 items without cost
                  console.log(`   ‚ö†Ô∏è Producto sin costo: ${articulo} (${item.description || 'sin descripci√≥n'})`);
                }
              }
            });
          }
        });
        console.log(`   - Items con costo: ${itemsWithCost}`);
        console.log(`   - Items sin costo: ${itemsWithoutCost}`);

        console.log(`\nüí∞ KPIs calculados:`);
        console.log(`   - Venta Total: $${totalRevenue.toFixed(2)}`);
        console.log(`   - Costo de Venta: $${totalCost.toFixed(2)}`);
        console.log(`   - Ganancia Total: $${totalProfit.toFixed(2)}`);
        console.log(`   - Porcentaje de ganancia: ${(totalProfit / totalRevenue * 100).toFixed(2)}%`);

        // Show first 5 costs from map
        const first5Costs = Array.from(costMap.entries()).slice(0, 5);
        console.log(`\nüìã Primeros 5 costos del mapa:`);
        first5Costs.forEach(([articulo, cost]) => {
          console.log(`   - ${articulo}: $${cost}`);
        });

        // Generate charts
        generateStatusChart(orders);
        generateSalesChart(orders);
        generateSalesByMonthChart(orders);
        generateSalesByYearChart(orders);

        // Generate rankings
        generateVendedoresRanking(orders, getClientDisplayName);
        generateProductosRanking(orders);
        await generateUsuariosRanking();

        // Generate device and browser charts
        await generateDevicesChart();
        await generateBrowsersChart();

        // Generate page visits chart
        await generatePagesChart();

        // Hide loading and show content
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('statsContent').style.display = 'block';

        console.log('‚úÖ Estad√≠sticas cargadas completamente');

      } catch (error) {
        console.error('‚ùå Error cargando estad√≠sticas:', error);
        alert('Error cargando estad√≠sticas: ' + error.message);
      }
    }

    function generateStatusChart(orders) {
      const statusCount = {};
      orders.forEach(order => {
        const status = order.logisticsState || 'sin estado';
        statusCount[status] = (statusCount[status] || 0) + 1;
      });

      const ctx = document.getElementById('statusChart').getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: Object.keys(statusCount),
          datasets: [{
            label: 'Cantidad de √ìrdenes',
            data: Object.values(statusCount),
            backgroundColor: [
              '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
              '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0'
            ],
            borderColor: '#1a1a1a',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                color: 'white',
                precision: 0
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            x: {
              ticks: {
                color: 'white'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          },
          plugins: {
            legend: {
              display: false
            }
          }
        }
      });
    }

    function generateSalesChart(orders) {
      // Group orders by date (last 30 days)
      const today = new Date();
      const last30Days = new Date(today);
      last30Days.setDate(today.getDate() - 30);

      const salesByDate = {};

      orders.forEach(order => {
        if (order.timestamp) {
          let orderDate;
          if (order.timestamp.toDate) {
            orderDate = order.timestamp.toDate();
          } else if (order.timestamp instanceof Date) {
            orderDate = order.timestamp;
          } else {
            orderDate = new Date(order.timestamp);
          }

          if (orderDate >= last30Days) {
            const dateKey = orderDate.toISOString().split('T')[0];
            salesByDate[dateKey] = (salesByDate[dateKey] || 0) + (order.total || 0);
          }
        }
      });

      // Sort dates and prepare data
      const sortedDates = Object.keys(salesByDate).sort();
      const salesData = sortedDates.map(date => salesByDate[date]);

      const ctx = document.getElementById('salesChart').getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedDates,
          datasets: [{
            label: 'Ventas ($)',
            data: salesData,
            borderColor: '#4CAF50',
            backgroundColor: 'rgba(76, 175, 80, 0.2)',
            tension: 0.4,
            fill: true,
            pointBackgroundColor: '#4CAF50',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: '#4CAF50'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              ticks: {
                color: 'white'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: 'white'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });
    }

    function generateSalesByMonthChart(orders) {
      // Group orders by month (last 12 months)
      const salesByMonth = {};
      const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];

      orders.forEach(order => {
        if (order.timestamp) {
          let orderDate;
          if (order.timestamp.toDate) {
            orderDate = order.timestamp.toDate();
          } else if (order.timestamp instanceof Date) {
            orderDate = order.timestamp;
          } else {
            orderDate = new Date(order.timestamp);
          }

          const year = orderDate.getFullYear();
          const month = orderDate.getMonth();
          const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;

          salesByMonth[monthKey] = (salesByMonth[monthKey] || 0) + (order.total || 0);
        }
      });

      // Get last 12 months
      const today = new Date();
      const months = [];
      const monthLabels = [];

      for (let i = 11; i >= 0; i--) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const year = date.getFullYear();
        const month = date.getMonth();
        const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
        months.push(monthKey);
        monthLabels.push(`${monthNames[month]} ${year}`);
      }

      const salesData = months.map(month => salesByMonth[month] || 0);

      const ctx = document.getElementById('salesByMonthChart').getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: monthLabels,
          datasets: [{
            label: 'Ventas ($)',
            data: salesData,
            borderColor: '#4CAF50',
            backgroundColor: 'rgba(76, 175, 80, 0.2)',
            tension: 0.4,
            fill: true,
            pointBackgroundColor: '#4CAF50',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: '#4CAF50'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              ticks: {
                color: 'white'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: 'white'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });
    }

    function generateSalesByYearChart(orders) {
      // Group orders by year
      const salesByYear = {};

      orders.forEach(order => {
        if (order.timestamp) {
          let orderDate;
          if (order.timestamp.toDate) {
            orderDate = order.timestamp.toDate();
          } else if (order.timestamp instanceof Date) {
            orderDate = order.timestamp;
          } else {
            orderDate = new Date(order.timestamp);
          }

          const year = orderDate.getFullYear();
          salesByYear[year] = (salesByYear[year] || 0) + (order.total || 0);
        }
      });

      // Sort years and prepare data
      const sortedYears = Object.keys(salesByYear).sort();
      const salesData = sortedYears.map(year => salesByYear[year]);

      const ctx = document.getElementById('salesByYearChart').getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedYears,
          datasets: [{
            label: 'Ventas ($)',
            data: salesData,
            borderColor: '#4CAF50',
            backgroundColor: 'rgba(76, 175, 80, 0.2)',
            tension: 0.4,
            fill: true,
            pointBackgroundColor: '#4CAF50',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: '#4CAF50'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              ticks: {
                color: 'white'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: 'white'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            }
          }
        }
      });
    }

    function generateVendedoresRanking(orders, getClientDisplayName) {
      const vendedoresStats = {};

      orders.forEach(order => {
        const vendedorEmail = order.usuarioEmail || 'Sin vendedor';
        // Map email to client name if applicable
        const vendedorKey = getClientDisplayName(vendedorEmail, order.clienteCodigo, order.clienteNombre);

        if (!vendedoresStats[vendedorKey]) {
          vendedoresStats[vendedorKey] = {
            ordenes: 0,
            revenue: 0,
            originalEmail: vendedorEmail
          };
        }
        vendedoresStats[vendedorKey].ordenes += 1;
        vendedoresStats[vendedorKey].revenue += (order.total || 0);
      });

      const ranking = Object.entries(vendedoresStats)
        .map(([displayName, stats]) => ({ displayName, ...stats }))
        .sort((a, b) => b.ordenes - a.ordenes)
        .slice(0, 10);

      const html = ranking.map((vendedor, index) => {
        const positionClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
        return `
          <li class="ranking-item">
            <div class="ranking-position ${positionClass}">${index + 1}</div>
            <div class="ranking-info">
              <div class="ranking-name">${vendedor.displayName}</div>
              <div class="ranking-detail">$${vendedor.revenue.toFixed(2)} en ventas</div>
            </div>
            <div class="ranking-value">
              ${vendedor.ordenes} <span class="unit">√≥rdenes</span>
            </div>
          </li>
        `;
      }).join('');

      document.getElementById('vendedoresRanking').innerHTML = html || '<li class="no-data">No hay datos disponibles</li>';
    }

    function generateProductosRanking(orders) {
      const productStats = {};

      orders.forEach(order => {
        if (order.items && Array.isArray(order.items)) {
          order.items.forEach(item => {
            const key = `${item.articulo || 'Sin c√≥digo'} - ${item.description || 'Sin descripci√≥n'}`;
            if (!productStats[key]) {
              productStats[key] = {
                cantidad: 0,
                revenue: 0,
                articulo: item.articulo || 'Sin c√≥digo',
                description: item.description || 'Sin descripci√≥n'
              };
            }
            productStats[key].cantidad += (item.quantity || 0);
            productStats[key].revenue += ((item.quantity || 0) * (item.price || 0));
          });
        }
      });

      const ranking = Object.values(productStats)
        .sort((a, b) => b.cantidad - a.cantidad)
        .slice(0, 10);

      const html = ranking.map((product, index) => {
        const positionClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
        return `
          <li class="ranking-item">
            <div class="ranking-position ${positionClass}">${index + 1}</div>
            <div class="ranking-info">
              <div class="ranking-name">${product.articulo}</div>
              <div class="ranking-detail">${product.description} ‚Ä¢ $${product.revenue.toFixed(2)}</div>
            </div>
            <div class="ranking-value">
              ${product.cantidad} <span class="unit">unidades</span>
            </div>
          </li>
        `;
      }).join('');

      document.getElementById('productosRanking').innerHTML = html || '<li class="no-data">No hay datos disponibles</li>';
    }

    async function updateAllLoginCounts() {
      console.log('üöÄ Funci√≥n updateAllLoginCounts llamada');

      const confirmed = confirm(
        '‚ö†Ô∏è ¬øEst√°s seguro de que deseas actualizar el loginCount?\n\n' +
        'Esta acci√≥n:\n' +
        '- Establecer√° loginCount = 1 para usuarios sin loginCount o con loginCount = 0\n' +
        '- Incrementar√° loginCount en +1 para usuarios que ya tienen loginCount >= 1\n' +
        '- Solo afectar√° usuarios aprobados (no pendientes)\n\n' +
        '¬øDeseas continuar?'
      );

      if (!confirmed) {
        console.log('üö´ Actualizaci√≥n de loginCount cancelada');
        return;
      }

      try {
        console.log('üîß Iniciando actualizaci√≥n de loginCount...');

        // Obtener todos los usuarios
        const usuariosSnapshot = await getDocs(collection(db, 'usuarios'));
        console.log(`üìä Total de usuarios en base de datos: ${usuariosSnapshot.size}`);

        let updatedCount = 0;
        let skippedCount = 0;

        // Procesar cada usuario
        for (const userDoc of usuariosSnapshot.docs) {
          const userData = userDoc.data();
          const userId = userDoc.id;

          console.log(`\nüîç Procesando: ${userData.email || userId}`);
          console.log(`   - approved: ${userData.approved}`);
          console.log(`   - role: ${userData.role}`);
          console.log(`   - loginCount actual: ${userData.loginCount || 0}`);

          // Solo actualizar usuarios aprobados (no pendientes)
          const isApproved = userData.approved !== false && userData.role !== 'pending';

          if (isApproved) {
            const currentLoginCount = userData.loginCount || 0;
            const newLoginCount = currentLoginCount === 0 ? 1 : currentLoginCount + 1;

            console.log(`   - ES APROBADO: actualizando de ${currentLoginCount} a ${newLoginCount}`);

            const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
            const userRef = doc(db, 'usuarios', userId);
            await updateDoc(userRef, { loginCount: newLoginCount });

            console.log(`‚úÖ ACTUALIZADO: ${userData.email || userId} - loginCount: ${currentLoginCount} ‚Üí ${newLoginCount}`);
            updatedCount++;
          } else {
            console.log(`‚è≠Ô∏è  NO APROBADO: omitiendo ${userData.email || userId}`);
            skippedCount++;
          }
        }

        console.log('\n' + '='.repeat(50));
        console.log('‚úÖ Actualizaci√≥n completada:');
        console.log(`   - Usuarios actualizados: ${updatedCount}`);
        console.log(`   - Usuarios omitidos (no aprobados): ${skippedCount}`);
        console.log(`   - Total procesado: ${usuariosSnapshot.size}`);
        console.log('='.repeat(50));

        alert(
          `‚úÖ Actualizaci√≥n completada exitosamente\n\n` +
          `üìä Usuarios actualizados: ${updatedCount}\n` +
          `‚è≠Ô∏è  Usuarios omitidos: ${skippedCount}\n` +
          `üìù Total procesado: ${usuariosSnapshot.size}\n\n` +
          `Recargando p√°gina en 2 segundos...`
        );

        // Recargar la p√°gina autom√°ticamente
        setTimeout(() => {
          location.reload();
        }, 2000);

      } catch (error) {
        console.error('‚ùå Error actualizando loginCount:', error);
        console.error('Stack trace:', error.stack);
        alert('‚ùå Error al actualizar loginCount: ' + error.message);
      }
    }

    async function generateUsuariosRanking() {
      try {
        const usuariosSnapshot = await getDocs(collection(db, 'usuarios'));
        const usuarios = [];

        // Lista de usuarios de prueba/desarrollo a excluir
        const testUsers = [
          'cristiansan@gmail.com',
          'santifn.axp@gmail.com',
          'matensegiles@gmail.com',
          'matense.giles@gmail.com',
          'test@test.com.ar',
          'test@test.com',
          'prueba@prueba.com',
          'cuenta@demo.com.ar'
        ];

        usuariosSnapshot.forEach(doc => {
          const data = doc.data();
          const email = data.email || '';

          // Excluir usuarios de prueba Y usuarios no aprobados
          const isTestUser = testUsers.includes(email.toLowerCase());
          const isNotApproved = data.approved === false || data.role === 'pending';

          if (!isTestUser && !isNotApproved) {
            usuarios.push({
              email: email,
              loginCount: data.loginCount || 0,
              lastLogin: data.lastLogin,
              displayName: data.displayName || email
            });
          }
        });

        console.log(`üë• Usuarios conectados despu√©s de filtrar: ${usuarios.length}`);

        const ranking = usuarios
          .sort((a, b) => b.loginCount - a.loginCount)
          .slice(0, 10);

        const html = ranking.map((user, index) => {
          const positionClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
          let lastLoginText = 'Nunca';
          if (user.lastLogin) {
            const date = user.lastLogin.toDate ? user.lastLogin.toDate() : new Date(user.lastLogin);
            lastLoginText = date.toLocaleDateString('es-AR');
          }

          return `
            <li class="ranking-item">
              <div class="ranking-position ${positionClass}">${index + 1}</div>
              <div class="ranking-info">
                <div class="ranking-name">${user.email}</div>
                <div class="ranking-detail">√öltimo login: ${lastLoginText}</div>
              </div>
              <div class="ranking-value">
                ${user.loginCount} <span class="unit">logins</span>
              </div>
            </li>
          `;
        }).join('');

        document.getElementById('usuariosRanking').innerHTML = html || '<li class="no-data">No hay datos disponibles</li>';
      } catch (error) {
        console.error('‚ùå Error cargando ranking de usuarios:', error);
        document.getElementById('usuariosRanking').innerHTML = '<li class="no-data">Error cargando datos</li>';
      }
    }

    async function generateDevicesChart() {
      try {
        // IMPORTANTE: Los datos son persistentes y permanentes en Firebase Firestore
        // Cada vez que un usuario hace login, se actualiza su lastDevice y loginCount
        // Esta estad√≠stica muestra el acumulado total desde octubre 2025
        // Los datos NO se borran autom√°ticamente y se mantienen indefinidamente
        const usuariosSnapshot = await getDocs(collection(db, 'usuarios'));
        const deviceCounts = {};
        const deviceUserDetails = {}; // Para debugging

        // Lista de usuarios de prueba a excluir (misma que generateUsuariosRanking)
        const testUsers = [
          'cristiansan@gmail.com',
          'santifn.axp@gmail.com',
          'matensegiles@gmail.com',
          'matense.giles@gmail.com',
          'test@test.com.ar',
          'test@test.com',
          'prueba@prueba.com',
          'cuenta@demo.com.ar'
        ];

        usuariosSnapshot.forEach(doc => {
          const data = doc.data();
          const email = data.email || '';
          const isTestUser = testUsers.includes(email.toLowerCase());
          const isNotApproved = data.approved === false || data.role === 'pending';

          if (!isTestUser && !isNotApproved) {
            const loginCount = data.loginCount || 0;
            const lastDevice = data.lastDevice;

            // Solo contar si tiene un dispositivo v√°lido (no Unknown, no undefined, no null)
            // Contar los logins totales usando el √∫ltimo dispositivo usado
            // Nota: Esto asume que todos los logins fueron con el √∫ltimo dispositivo
            // Para datos hist√≥ricos m√°s precisos, se necesitar√≠a una colecci√≥n de login_history
            if (lastDevice && lastDevice !== 'Unknown' && lastDevice !== '' && loginCount > 0) {
              deviceCounts[lastDevice] = (deviceCounts[lastDevice] || 0) + loginCount;

              // Guardar detalles para debugging
              if (!deviceUserDetails[lastDevice]) {
                deviceUserDetails[lastDevice] = [];
              }
              deviceUserDetails[lastDevice].push({
                email: email,
                loginCount: loginCount,
                lastDevice: lastDevice
              });
            }
          }
        });

        // Log detallado de dispositivos
        console.log('üì± Total de conexiones por dispositivo (acumulado desde octubre 2025):');
        Object.entries(deviceCounts).forEach(([device, count]) => {
          console.log(`   - ${device}: ${count} logins`);
        });

        // Mostrar detalles de iPad si existe
        if (deviceCounts['iPad']) {
          console.log(`\nüì± Detalles de conexiones desde iPad:`);
          deviceUserDetails['iPad'].forEach(user => {
            console.log(`   - ${user.email}: ${user.loginCount} logins`);
          });
        } else {
          console.log(`\n‚ö†Ô∏è No se encontraron conexiones desde iPad`);
        }

        const labels = Object.keys(deviceCounts);
        const data = Object.values(deviceCounts);

        const ctx = document.getElementById('devicesChart').getContext('2d');
        new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: labels,
            datasets: [{
              data: data,
              backgroundColor: [
                '#4CAF50', // Verde
                '#2196F3', // Azul
                '#FFC107', // Amarillo
                '#FF5722', // Rojo-naranja
                '#9C27B0', // P√∫rpura
                '#00BCD4', // Cian
                '#FF9800', // Naranja
                '#607D8B'  // Gris azulado
              ],
              borderColor: '#1a1a1a',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  color: 'white',
                  padding: 15,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const label = context.label || '';
                    const value = context.parsed || 0;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = ((value / total) * 100).toFixed(1);
                    return `${label}: ${value} logins (${percentage}%)`;
                  }
                }
              }
            }
          }
        });

        console.log('üì± Gr√°fico de dispositivos generado:', deviceCounts);
      } catch (error) {
        console.error('‚ùå Error generando gr√°fico de dispositivos:', error);
      }
    }

    async function generateBrowsersChart() {
      try {
        const usuariosSnapshot = await getDocs(collection(db, 'usuarios'));
        const browserCounts = {};

        // Lista de usuarios de prueba a excluir
        const testUsers = [
          'cristiansan@gmail.com',
          'santifn.axp@gmail.com',
          'matensegiles@gmail.com',
          'matense.giles@gmail.com',
          'test@test.com.ar',
          'test@test.com',
          'prueba@prueba.com',
          'cuenta@demo.com.ar'
        ];

        usuariosSnapshot.forEach(doc => {
          const data = doc.data();
          const email = data.email || '';
          const isTestUser = testUsers.includes(email.toLowerCase());
          const isNotApproved = data.approved === false || data.role === 'pending';

          if (!isTestUser && !isNotApproved) {
            const loginCount = data.loginCount || 0;
            const lastBrowser = data.lastBrowser;

            // Solo contar si tiene un navegador v√°lido (no Unknown, no undefined, no null)
            if (lastBrowser && lastBrowser !== 'Unknown' && lastBrowser !== '' && loginCount > 0) {
              browserCounts[lastBrowser] = (browserCounts[lastBrowser] || 0) + loginCount;
            }
          }
        });

        // Log detallado de navegadores
        console.log('\nüåê Total de conexiones por navegador (acumulado desde octubre 2025):');
        Object.entries(browserCounts).forEach(([browser, count]) => {
          console.log(`   - ${browser}: ${count} logins`);
        });

        const labels = Object.keys(browserCounts);
        const data = Object.values(browserCounts);

        const ctx = document.getElementById('browsersChart').getContext('2d');
        new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: labels,
            datasets: [{
              data: data,
              backgroundColor: [
                '#4CAF50', // Verde - Chrome
                '#2196F3', // Azul - Edge
                '#FFC107', // Amarillo - Firefox
                '#FF5722', // Rojo - Safari
                '#9C27B0', // P√∫rpura - Opera
                '#00BCD4', // Cian
                '#FF9800', // Naranja
                '#607D8B'  // Gris azulado
              ],
              borderColor: '#1a1a1a',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  color: 'white',
                  padding: 15,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const label = context.label || '';
                    const value = context.parsed || 0;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = ((value / total) * 100).toFixed(1);
                    return `${label}: ${value} logins (${percentage}%)`;
                  }
                }
              }
            }
          }
        });

        console.log('üåê Gr√°fico de navegadores generado:', browserCounts);
      } catch (error) {
        console.error('‚ùå Error generando gr√°fico de navegadores:', error);
      }
    }

    async function generatePagesChart() {
      try {
        const pageVisitsSnapshot = await getDocs(collection(db, 'page_visits'));
        const pageCounts = {};

        pageVisitsSnapshot.forEach(doc => {
          const data = doc.data();
          const pageName = data.pageName || data.page || 'Unknown';

          if (pageName && pageName !== 'Unknown') {
            pageCounts[pageName] = (pageCounts[pageName] || 0) + 1;
          }
        });

        // Verificar si hay suficientes datos
        const totalVisits = Object.values(pageCounts).reduce((a, b) => a + b, 0);
        const uniquePages = Object.keys(pageCounts).length;

        // Log detallado de p√°ginas visitadas
        console.log('\nüìä Total de visitas por p√°gina (acumulado desde octubre 2025):');
        console.log(`   üìà Total de visitas registradas: ${totalVisits}`);
        console.log(`   üìÑ P√°ginas √∫nicas visitadas: ${uniquePages}`);
        Object.entries(pageCounts).sort((a, b) => b[1] - a[1]).forEach(([page, count]) => {
          console.log(`   - ${page}: ${count} visitas`);
        });

        if (uniquePages < 3) {
          console.log(`\n‚ö†Ô∏è Pocas p√°ginas registradas. Visita m√°s p√°ginas (Marketplace, Carrito, Index, Ayuda, etc.) para ver estad√≠sticas completas.`);

          // Actualizar subt√≠tulo con mensaje informativo
          const subtitle = document.getElementById('pagesChartSubtitle');
          if (subtitle) {
            subtitle.innerHTML = `
              Acumulado desde octubre 2025<br>
              <span style="color: #FFC107; margin-top: 5px; display: inline-block;">
                ‚ö†Ô∏è Visita m√°s p√°ginas para generar estad√≠sticas completas
              </span>
            `;
          }
        }

        const labels = Object.keys(pageCounts);
        const data = Object.values(pageCounts);

        const ctx = document.getElementById('pagesChart').getContext('2d');
        new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [{
              label: 'Visitas',
              data: data,
              backgroundColor: [
                '#4CAF50', // Verde
                '#2196F3', // Azul
                '#FFC107', // Amarillo
                '#FF5722', // Rojo-naranja
                '#9C27B0', // P√∫rpura
                '#00BCD4', // Cian
                '#FF9800', // Naranja
                '#607D8B', // Gris azulado
                '#E91E63', // Rosa
                '#795548'  // Marr√≥n
              ],
              borderColor: '#1a1a1a',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  color: 'white',
                  precision: 0
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.1)'
                }
              },
              x: {
                ticks: {
                  color: 'white'
                },
                grid: {
                  color: 'rgba(255, 255, 255, 0.1)'
                }
              }
            },
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const label = context.label || '';
                    const value = context.parsed.y || 0;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = ((value / total) * 100).toFixed(1);
                    return `${label}: ${value} visitas (${percentage}%)`;
                  }
                }
              }
            }
          }
        });

        console.log('üìä Gr√°fico de p√°ginas visitadas generado:', pageCounts);
      } catch (error) {
        console.error('‚ùå Error generando gr√°fico de p√°ginas visitadas:', error);
      }
    }

    async function migrateDeviceHistory() {
      console.log('üöÄ Iniciando migraci√≥n de historial de dispositivos...');

      const confirmed = confirm(
        '‚ö†Ô∏è ¬øMigrar historial de dispositivos y navegadores?\n\n' +
        'Esta acci√≥n:\n' +
        '- Tomar√° el lastDevice de cada usuario y lo agregar√° a usedDevices[]\n' +
        '- Tomar√° el lastBrowser de cada usuario y lo agregar√° a usedBrowsers[]\n' +
        '- Recupera el historial de dispositivos previo a este cambio\n' +
        '- Solo afecta usuarios que no tienen estos arrays o est√°n vac√≠os\n\n' +
        '¬øDeseas continuar?'
      );

      if (!confirmed) {
        console.log('üö´ Migraci√≥n cancelada');
        return;
      }

      try {
        const usuariosSnapshot = await getDocs(collection(db, 'usuarios'));
        console.log(`üìä Total de usuarios: ${usuariosSnapshot.size}`);

        let migratedCount = 0;
        let skippedCount = 0;

        for (const userDoc of usuariosSnapshot.docs) {
          const userData = userDoc.data();
          const userId = userDoc.id;

          const currentUsedDevices = userData.usedDevices || [];
          const currentUsedBrowsers = userData.usedBrowsers || [];

          let needsUpdate = false;
          const updates = {};

          // Migrar lastDevice si existe y no est√° en el array
          if (userData.lastDevice && !currentUsedDevices.includes(userData.lastDevice)) {
            updates.usedDevices = [...currentUsedDevices, userData.lastDevice];
            needsUpdate = true;
            console.log(`üì± Migrando dispositivo "${userData.lastDevice}" para ${userData.email || userId}`);
          }

          // Migrar lastBrowser si existe y no est√° en el array
          if (userData.lastBrowser && !currentUsedBrowsers.includes(userData.lastBrowser)) {
            updates.usedBrowsers = [...currentUsedBrowsers, userData.lastBrowser];
            needsUpdate = true;
            console.log(`üåê Migrando navegador "${userData.lastBrowser}" para ${userData.email || userId}`);
          }

          if (needsUpdate) {
            const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
            const userRef = doc(db, 'usuarios', userId);
            await updateDoc(userRef, updates);
            console.log(`‚úÖ Migrado: ${userData.email || userId}`);
            migratedCount++;
          } else {
            skippedCount++;
          }
        }

        console.log('\n' + '='.repeat(50));
        console.log('‚úÖ Migraci√≥n completada:');
        console.log(`   - Usuarios migrados: ${migratedCount}`);
        console.log(`   - Usuarios omitidos: ${skippedCount}`);
        console.log(`   - Total procesado: ${usuariosSnapshot.size}`);
        console.log('='.repeat(50));

        alert(
          `‚úÖ Migraci√≥n completada exitosamente\n\n` +
          `üìä Usuarios migrados: ${migratedCount}\n` +
          `‚è≠Ô∏è  Usuarios omitidos: ${skippedCount}\n` +
          `üìù Total procesado: ${usuariosSnapshot.size}\n\n` +
          `Recargando p√°gina en 2 segundos...`
        );

        setTimeout(() => {
          location.reload();
        }, 2000);

      } catch (error) {
        console.error('‚ùå Error en migraci√≥n:', error);
        alert('‚ùå Error en migraci√≥n: ' + error.message);
      }
    }

    // Make functions globally accessible
    window.updateAllLoginCounts = updateAllLoginCounts;
    window.migrateDeviceHistory = migrateDeviceHistory;
  </script>
</body>
</html>
